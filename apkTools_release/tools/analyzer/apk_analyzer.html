<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APK ä¿¡æ¯æå–å·¥å…·</title>
    <link rel="stylesheet" href="../../assets/css/theme.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/forge/1.3.1/forge.min.js"></script>
    <style>
        /* ç»§æ‰¿theme.cssçš„åŸºç¡€æ ·å¼ */
        /* ä»¥ä¸‹æ˜¯å·¥å…·é¡µé¢ç‰¹å®šçš„æ ·å¼è¦†ç›– */

        .container {
            max-width: 900px;
        }

        .home-btn {
            position: absolute;
            top: var(--spacing-lg);
            left: var(--spacing-lg);
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: var(--radius-full);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text-on-primary);
            text-decoration: none;
            font-size: var(--font-size-large);
            transition: all .3s;
            z-index: 10;
        }

        .home-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .header h1 {
            font-size: var(--font-size-xlarge);
            margin-bottom: var(--spacing-sm);
        }

        .header p {
            opacity: 0.9;
            font-size: var(--font-size-small);
        }

        .content {
            padding: var(--spacing-xl);
        }

        .upload-area {
            border: 3px dashed var(--color-primary);
            border-radius: var(--radius-md);
            padding: var(--spacing-xxl);
            text-align: center;
            background: var(--color-background-alt);
            transition: all 0.3s;
            cursor: pointer;
        }

        .upload-area:hover {
            background: var(--color-surface-alt);
            border-color: var(--color-primary-dark);
        }

        .upload-area.dragover {
            background: var(--color-hover);
            border-color: var(--color-primary);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: var(--spacing-md);
        }

        .upload-text {
            font-size: var(--font-size-base);
            color: var(--color-text);
            margin-bottom: var(--spacing-sm);
        }

        .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            color: var(--color-text-on-primary);
            border: none;
            padding: var(--spacing-sm) var(--spacing-xl);
            border-radius: var(--radius-sm);
            font-size: var(--font-size-base);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .btn:active {
            transform: translateY(0);
        }

        .results {
            margin-top: var(--spacing-xl);
            display: none;
        }

        .results.show {
            display: block;
        }

        .result-item {
            background: var(--color-background-alt);
            border-left: 4px solid var(--color-primary);
            padding: var(--spacing-md) var(--spacing-lg);
            margin-bottom: var(--spacing-md);
            border-radius: var(--radius-sm);
        }

        .result-label {
            font-weight: 600;
            color: #495057;
            margin-bottom: 8px;
            font-size: var(--font-size-small);
        }

        .result-value-wrapper {
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .result-value {
            color: #212529;
            word-break: break-all;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            background: var(--color-surface);
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            flex: 1;
            white-space: pre-line;
        }

        .loading {
            text-align: center;
            padding: 20px;
            display: none;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .error {
            background: #fee;
            border-left-color: #dc3545;
            color: #721c24;
            padding: var(--spacing-md);
            border-radius: var(--radius-sm);
            margin-top: 20px;
            display: none;
        }

        .error.show {
            display: block;
        }

        .copy-btn {
            background: #667eea;
            color: var(--color-text-on-primary);
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .copy-btn:hover {
            background: #764ba2;
            transform: translateY(-1px);
        }

        .copy-btn:active {
            transform: translateY(0);
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <a href="../../index.html" class="home-btn" title="è¿”å›é¦–é¡µ">ğŸ </a>
            <h1>ğŸ“¦ APK ä¿¡æ¯æå–å·¥å…·</h1>
            <p>è§£æ APKï¼Œè¯»å–åŒ…åä¸è¯ä¹¦æŒ‡çº¹ç­‰ä¿¡æ¯ï¼Œæ”¯æŒæ‹–æ‹½ä¸Šä¼ ä¸ç»“æœå¤åˆ¶ã€‚</p>
        </div>
        <div class="content">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">ğŸ“¦</div>
                <div class="upload-text">ç‚¹å‡»é€‰æ‹©æ–‡ä»¶æˆ–æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„</div>
                <div style="font-size: var(--font-size-small); color: #6c757d; margin-top: 10px;">æ”¯æŒæ ¼å¼ï¼šAPK (.apk) | Keystore (.keystore) |
                    JKS (.jks)</div>
                <input type="file" id="fileInput" class="file-input" accept=".apk,.keystore,.jks">
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div>æ­£åœ¨è§£æ APK æ–‡ä»¶...</div>
            </div>

            <div class="error" id="error"></div>

            <div class="results" id="results">
                <div class="result-item">
                    <div class="result-label">å…¬é’¥ï¼ˆå¤§æ•´æ•°æ ¼å¼ï¼‰</div>
                    <div class="result-value-wrapper">
                        <div class="result-value" id="publicKey">-</div>
                        <button class="copy-btn" data-target="publicKey">å¤åˆ¶</button>
                    </div>
                </div>
                <div class="result-item">
                    <div class="result-label">MD5 æŒ‡çº¹</div>
                    <div class="result-value-wrapper">
                        <div class="result-value" id="md5">-</div>
                        <div style="display: flex; gap: 5px;">
                            <button class="copy-btn" data-target="md5" data-style="space">å¤åˆ¶ç©ºæ ¼</button>
                            <button class="copy-btn" data-target="md5" data-style="colon">å¤åˆ¶å†’å·</button>
                        </div>
                    </div>
                </div>
                <div class="result-item">
                    <div class="result-label">SHA1 æŒ‡çº¹</div>
                    <div class="result-value-wrapper">
                        <div class="result-value" id="sha1">-</div>
                        <div style="display: flex; gap: 5px;">
                            <button class="copy-btn" data-target="sha1" data-style="space">å¤åˆ¶ç©ºæ ¼</button>
                            <button class="copy-btn" data-target="sha1" data-style="colon">å¤åˆ¶å†’å·</button>
                        </div>
                    </div>
                </div>
                <div class="result-item">
                    <div class="result-label">SHA256 æŒ‡çº¹</div>
                    <div class="result-value-wrapper">
                        <div class="result-value" id="sha256">-</div>
                        <div style="display: flex; gap: 5px;">
                            <button class="copy-btn" data-target="sha256" data-style="space">å¤åˆ¶ç©ºæ ¼</button>
                            <button class="copy-btn" data-target="sha256" data-style="colon">å¤åˆ¶å†’å·</button>
                        </div>
                    </div>
                </div>
                <div class="result-item" id="aliasItem" style="display: none;">
                    <div class="result-label">å¯†é’¥åˆ«å (keyAlias)</div>
                    <div class="result-value-wrapper">
                        <div class="result-value" id="alias">-</div>
                        <button class="copy-btn" data-target="alias">å¤åˆ¶</button>
                    </div>
                </div>
                <div class="result-item" id="storePasswordItem" style="display: none;">
                    <div class="result-label">å¯†é’¥åº“å¯†ç  (storePassword)</div>
                    <div class="result-value-wrapper">
                        <div class="result-value" id="storePassword">-</div>
                        <button class="copy-btn" data-target="storePassword">å¤åˆ¶</button>
                    </div>
                </div>
                <div class="result-item" id="keyPasswordItem" style="display: none;">
                    <div class="result-label">å¯†é’¥å¯†ç  (keyPassword)</div>
                    <div class="result-value-wrapper">
                        <div class="result-value" id="keyPassword">-</div>
                        <button class="copy-btn" data-target="keyPassword">å¤åˆ¶</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const loading = document.getElementById('loading');
        const results = document.getElementById('results');
        const error = document.getElementById('error');

        // ç‚¹å‡»ä¸Šä¼ åŒºåŸŸ
        uploadArea.addEventListener('click', () => fileInput.click());

        // æ–‡ä»¶é€‰æ‹©
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // æ‹–æ‹½ä¸Šä¼ 
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });

        async function handleFile(file) {
            const fileName = file.name.toLowerCase();
            const isAPK = fileName.endsWith('.apk');
            const isKeystore = fileName.endsWith('.keystore') || fileName.endsWith('.jks');

            if (!isAPK && !isKeystore) {
                showError('è¯·é€‰æ‹© APKã€Keystore æˆ– JKS æ–‡ä»¶');
                return;
            }

            loading.classList.add('show');
            results.classList.remove('show');
            error.classList.remove('show');

            try {
                const arrayBuffer = await file.arrayBuffer();
                console.log('æ–‡ä»¶å¤§å°:', arrayBuffer.byteLength, 'å­—èŠ‚');

                if (isAPK) {
                    await analyzeAPK(arrayBuffer);
                } else if (isKeystore) {
                    await analyzeKeystore(arrayBuffer, file.name);
                }
            } catch (err) {
                console.error('è§£æé”™è¯¯:', err);
                showError('è§£æå¤±è´¥: ' + err.message + (err.stack ? '\n' + err.stack : ''));
            } finally {
                loading.classList.remove('show');
            }
        }

        async function analyzeAPK(arrayBuffer) {
            try {
                console.log('å¼€å§‹åŠ è½½ ZIP...');
                const zip = await JSZip.loadAsync(arrayBuffer);

                // æå–ç­¾åä¿¡æ¯
                console.log('å¼€å§‹æå–ç­¾åä¿¡æ¯...');
                const signatureInfo = await extractSignatureInfo(zip, arrayBuffer);
                console.log('ç­¾åä¿¡æ¯:', signatureInfo);
                // å°è¯•ä»å†å²è®°å½•ä¸­åŒ¹é…å¯†ç ä¿¡æ¯ï¼ˆä½¿ç”¨åŸå§‹æ•°æ®ï¼‰
                const md5Formatted = window.lastHashData ? window.lastHashData.md5 : (signatureInfo.md5 ? signatureInfo.md5.replace(/[\s:]/g, '').toUpperCase() : null);
                const matchedInfo = signatureInfo.publicKey ? findMatchingHistory(signatureInfo.publicKey, md5Formatted) : null;

                document.getElementById('publicKey').textContent = signatureInfo.publicKey || '-';
                document.getElementById('md5').textContent = signatureInfo.md5 || '-';
                document.getElementById('sha1').textContent = signatureInfo.sha1 || '-';
                document.getElementById('sha256').textContent = signatureInfo.sha256 || '-';

                // æ˜¾ç¤º keyAlias
                const keyAlias = matchedInfo ? (matchedInfo.keyAlias || matchedInfo.alias) : (signatureInfo.alias || null);
                if (keyAlias) {
                    document.getElementById('alias').textContent = keyAlias;
                    document.getElementById('aliasItem').style.display = 'block';
                } else {
                    document.getElementById('aliasItem').style.display = 'none';
                }

                // æ˜¾ç¤º storePassword
                if (matchedInfo && matchedInfo.storePassword) {
                    document.getElementById('storePassword').textContent = matchedInfo.storePassword || matchedInfo.password || 'æœªæ‰¾åˆ°';
                    document.getElementById('storePasswordItem').style.display = 'block';
                } else {
                    document.getElementById('storePassword').textContent = 'æœªæ‰¾åˆ°ï¼ˆæ— æ³•ä» APK ä¸­æå–ï¼Œè¯·æŸ¥çœ‹å†å²è®°å½•ï¼‰';
                    document.getElementById('storePasswordItem').style.display = 'block';
                }

                // æ˜¾ç¤º keyPassword
                if (matchedInfo && matchedInfo.keyPassword) {
                    document.getElementById('keyPassword').textContent = matchedInfo.keyPassword;
                    document.getElementById('keyPasswordItem').style.display = 'block';
                } else {
                    document.getElementById('keyPassword').textContent = 'æœªæ‰¾åˆ°ï¼ˆæ— æ³•ä» APK ä¸­æå–ï¼Œè¯·æŸ¥çœ‹å†å²è®°å½•ï¼‰';
                    document.getElementById('keyPasswordItem').style.display = 'block';
                }

                results.classList.add('show');

                // æ£€æŸ¥æ˜¯å¦æœ‰ä¿¡æ¯ç¼ºå¤±
                if (!signatureInfo.publicKey || !signatureInfo.md5) {
                    showError('è­¦å‘Š: éƒ¨åˆ†ç­¾åä¿¡æ¯æå–å¤±è´¥ï¼Œå¯èƒ½æ˜¯ä½¿ç”¨äº†æ–°çš„ç­¾åæ–¹æ¡ˆï¼ˆv2/v3ï¼‰');
                }
            } catch (err) {
                console.error('APK è§£æé”™è¯¯:', err);
                throw new Error('APK è§£æé”™è¯¯: ' + err.message);
            }
        }

        async function extractSignatureInfo(zip, arrayBuffer) {
            const info = {
                publicKey: null,
                md5: null,
                sha256: null
            };

            try {
                // æ–¹æ³•1: æŸ¥æ‰¾ META-INF ä¸­çš„è¯ä¹¦æ–‡ä»¶
                console.log('æŸ¥æ‰¾ META-INF ä¸­çš„è¯ä¹¦æ–‡ä»¶...');
                let certData = null;
                let certFileName = null;

                // åˆ—å‡ºæ‰€æœ‰ META-INF æ–‡ä»¶
                const metaInfFiles = Object.keys(zip.files).filter(f => f.startsWith('META-INF/'));
                console.log('META-INF æ–‡ä»¶:', metaInfFiles);

                for (const filename of metaInfFiles) {
                    if (filename.endsWith('.RSA') || filename.endsWith('.DSA') || filename.endsWith('.EC')) {
                        console.log('æ‰¾åˆ°è¯ä¹¦æ–‡ä»¶:', filename);
                        const file = zip.file(filename);
                        if (file) {
                            certData = await file.async('uint8array');
                            certFileName = filename;
                            console.log('è¯ä¹¦æ–‡ä»¶å¤§å°:', certData.length, 'å­—èŠ‚');
                            break;
                        }
                    }
                }

                // æ–¹æ³•2: å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå°è¯•ä» APK Signature Block ä¸­æå–
                if (!certData) {
                    console.log('æœªæ‰¾åˆ° META-INF è¯ä¹¦ï¼Œå°è¯•ä»ç­¾åå—æå–...');
                    certData = await extractFromSignatureBlock(arrayBuffer);
                }

                if (certData && certData.length > 0) {
                    console.log('å¼€å§‹è®¡ç®—å“ˆå¸Œå€¼...');
                    // è®¡ç®—å“ˆå¸Œ
                    const md5Hash = await calculateHash(certData, 'MD5');
                    const sha1Hash = await calculateHash(certData, 'SHA-1');
                    const sha256Hash = await calculateHash(certData, 'SHA-256');

                    // ä¿å­˜åŸå§‹æ•°æ®ï¼ˆè½¬æ¢ä¸ºåå…­è¿›åˆ¶å­—ç¬¦ä¸²ï¼Œå»é™¤åˆ†éš”ç¬¦ï¼‰
                    window.lastHashData = {
                        md5: Array.from(md5Hash).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase(),
                        sha1: Array.from(sha1Hash).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase(),
                        sha256: Array.from(sha256Hash).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase()
                    };

                    // formatHash ç°åœ¨è¿”å›ä¸¤ç§æ ¼å¼
                    info.md5 = formatHash(md5Hash);
                    info.sha1 = formatHash(sha1Hash);
                    info.sha256 = formatHash(sha256Hash);

                    console.log('MD5:', info.md5);
                    console.log('SHA1:', info.sha1);
                    console.log('SHA256:', info.sha256);

                    // æå–å…¬é’¥
                    console.log('å¼€å§‹æå–å…¬é’¥...');
                    info.publicKey = await extractPublicKey(certData);
                    console.log('å…¬é’¥é•¿åº¦:', info.publicKey ? info.publicKey.length : 0);
                } else {
                    console.warn('æœªæ‰¾åˆ°è¯ä¹¦æ•°æ®');
                    // å³ä½¿æ²¡æœ‰è¯ä¹¦ï¼Œä¹Ÿè®¡ç®—æ•´ä¸ª APK çš„å“ˆå¸Œ
                    const md5Hash = await calculateHash(new Uint8Array(arrayBuffer), 'MD5');
                    const sha1Hash = await calculateHash(new Uint8Array(arrayBuffer), 'SHA-1');
                    const sha256Hash = await calculateHash(new Uint8Array(arrayBuffer), 'SHA-256');
                    // ä¿å­˜åŸå§‹æ•°æ®ï¼ˆè½¬æ¢ä¸ºåå…­è¿›åˆ¶å­—ç¬¦ä¸²ï¼Œå»é™¤åˆ†éš”ç¬¦ï¼‰
                    window.lastHashData = {
                        md5: Array.from(md5Hash).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase(),
                        sha1: Array.from(sha1Hash).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase(),
                        sha256: Array.from(sha256Hash).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase()
                    };

                    // formatHash ç°åœ¨è¿”å›ä¸¤ç§æ ¼å¼ï¼ŒåŠ ä¸Šåç¼€
                    const md5Both = formatHash(md5Hash);
                    const sha1Both = formatHash(sha1Hash);
                    const sha256Both = formatHash(sha256Hash);
                    info.md5 = md5Both + '\n(æ•´ä¸ª APK)';
                    info.sha1 = sha1Both + '\n(æ•´ä¸ª APK)';
                    info.sha256 = sha256Both + '\n(æ•´ä¸ª APK)';
                }
            } catch (err) {
                console.error('æå–ç­¾åä¿¡æ¯å¤±è´¥:', err);
                throw err;
            }

            return info;
        }

        // åˆ†æ Keystore/JKS æ–‡ä»¶
        async function analyzeKeystore(arrayBuffer, fileName) {
            try {
                console.log('å¼€å§‹åˆ†æ Keystore æ–‡ä»¶...');

                // æç¤ºç”¨æˆ·è¾“å…¥å¯†ç 
                const password = prompt('è¯·è¾“å…¥ Keystore å¯†ç ï¼ˆå¦‚æœä¸ºç©ºåˆ™å°è¯•ç©ºå¯†ç ï¼‰:');
                // å¦‚æœç”¨æˆ·å–æ¶ˆï¼Œpassword ä¸º nullï¼›å¦‚æœç”¨æˆ·ç¡®è®¤ä½†ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œåˆ™å°è¯•ç©ºå¯†ç 
                const inputPassword = password === null ? null : (password || '');

                // å°† ArrayBuffer è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼ˆPKCS#12 æ ¼å¼ï¼‰
                const p12Der = new Uint8Array(arrayBuffer);
                const p12String = String.fromCharCode.apply(null, p12Der);

                try {
                    // è§£æ PKCS#12 æ ¼å¼
                    const p12Asn1 = forge.asn1.fromDer(p12String);
                    const p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, inputPassword === null ? false : inputPassword);

                    // è·å–æ‰€æœ‰å®‰å…¨å¯¹è±¡ï¼ˆè¯ä¹¦å’Œç§é’¥ï¼‰
                    const bags = p12.getBags({ bagType: forge.pki.oids.certBag });

                    if (!bags || bags[forge.pki.oids.certBag].length === 0) {
                        throw new Error('æœªæ‰¾åˆ°è¯ä¹¦ï¼Œè¯·æ£€æŸ¥å¯†ç æ˜¯å¦æ­£ç¡®');
                    }

                    // è·å–ç¬¬ä¸€ä¸ªè¯ä¹¦
                    const cert = bags[forge.pki.oids.certBag][0].cert;

                    // è·å–åˆ«åï¼ˆå¦‚æœæœ‰ï¼‰
                    let alias = null;
                    try {
                        const friendlyNames = p12.getBags({ bagType: forge.pki.oids.friendlyName });
                        if (friendlyNames && friendlyNames[forge.pki.oids.friendlyName].length > 0) {
                            alias = friendlyNames[forge.pki.oids.friendlyName][0].friendlyName;
                        }
                    } catch (e) {
                        console.warn('æ— æ³•è·å–åˆ«å:', e);
                    }

                    // è½¬æ¢ä¸º DER æ ¼å¼
                    const certDer = forge.pki.certificateToAsn1(cert);
                    const certAsn1 = forge.asn1.toDer(certDer).getBytes();
                    const certBuffer = new Uint8Array(certAsn1.length);
                    for (let i = 0; i < certAsn1.length; i++) {
                        certBuffer[i] = certAsn1.charCodeAt(i);
                    }

                    // è®¡ç®—å“ˆå¸Œ
                    const md5Hash = CryptoJS.MD5(CryptoJS.lib.WordArray.create(certBuffer));
                    const sha1Hash = CryptoJS.SHA1(CryptoJS.lib.WordArray.create(certBuffer));
                    const sha256Hash = CryptoJS.SHA256(CryptoJS.lib.WordArray.create(certBuffer));

                    // æå–å…¬é’¥
                    const publicKey = cert.publicKey;
                    let publicKeyModulus = null;

                    if (publicKey && publicKey.n) {
                        // RSA å…¬é’¥
                        publicKeyModulus = publicKey.n.toString();
                    } else {
                        // å°è¯•ä»è¯ä¹¦æ•°æ®ä¸­æå–
                        publicKeyModulus = await extractPublicKey(certBuffer);
                    }

                    // æ ¼å¼åŒ– MD5 ç”¨äºåŒ¹é…ï¼ˆmd5Hash æ˜¯ CryptoJS å¯¹è±¡ï¼Œéœ€è¦è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼‰
                    const md5HashStr = md5Hash.toString().replace(/[\s:]/g, '').toUpperCase();
                    const sha1HashStr = sha1Hash.toString().replace(/[\s:]/g, '').toUpperCase();
                    const sha256HashStr = sha256Hash.toString().replace(/[\s:]/g, '').toUpperCase();
                    const md5Formatted = formatHash(md5HashStr, 'space');

                    // ä¿å­˜åŸå§‹æ•°æ®ï¼ˆä¿å­˜ä¸ºå­—ç¬¦ä¸²ï¼Œå»é™¤ç©ºæ ¼å’Œå†’å·ï¼‰
                    window.lastHashData = {
                        md5: md5HashStr,
                        sha1: sha1HashStr,
                        sha256: sha256HashStr
                    };

                    // å°è¯•ä»å†å²è®°å½•ä¸­åŒ¹é…å¯†ç ä¿¡æ¯
                    const matchedInfo = findMatchingHistory(publicKeyModulus, md5Formatted);

                    // å¦‚æœç”¨æˆ·è¾“å…¥äº†å¯†ç ä¸”è§£ææˆåŠŸï¼Œä¼˜å…ˆä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„å¯†ç 
                    // inputPassword ä¸º null è¡¨ç¤ºç”¨æˆ·å–æ¶ˆäº†è¾“å…¥
                    const finalStorePassword = inputPassword !== null ? inputPassword : (matchedInfo ? (matchedInfo.storePassword || matchedInfo.password) : null);
                    const finalKeyPassword = inputPassword !== null ? inputPassword : (matchedInfo ? matchedInfo.keyPassword : null);

                    const signatureInfo = {
                        publicKey: publicKeyModulus || 'æ— æ³•æå–å…¬é’¥',
                        md5: formatHash(md5HashStr),
                        sha1: formatHash(sha1HashStr),
                        sha256: formatHash(sha256HashStr),
                        keyAlias: matchedInfo ? (matchedInfo.keyAlias || matchedInfo.alias) : (alias || 'æœªæ‰¾åˆ°åˆ«å'),
                        storePassword: finalStorePassword,
                        keyPassword: finalKeyPassword
                    };

                    console.log('ç­¾åä¿¡æ¯:', signatureInfo);
                    document.getElementById('publicKey').textContent = signatureInfo.publicKey;
                    document.getElementById('md5').textContent = signatureInfo.md5;
                    document.getElementById('sha1').textContent = signatureInfo.sha1;
                    document.getElementById('sha256').textContent = signatureInfo.sha256;

                    // æ˜¾ç¤º keyAlias
                    document.getElementById('alias').textContent = signatureInfo.keyAlias;
                    document.getElementById('aliasItem').style.display = 'block';

                    // æ˜¾ç¤º storePassword
                    if (signatureInfo.storePassword !== null && signatureInfo.storePassword !== undefined) {
                        document.getElementById('storePassword').textContent = signatureInfo.storePassword;
                        document.getElementById('storePasswordItem').style.display = 'block';
                    } else {
                        document.getElementById('storePassword').textContent = 'æœªæ‰¾åˆ°ï¼ˆæ— æ³•ä»æ–‡ä»¶ä¸­æå–ï¼Œè¯·æŸ¥çœ‹å†å²è®°å½•ï¼‰';
                        document.getElementById('storePasswordItem').style.display = 'block';
                    }

                    // æ˜¾ç¤º keyPassword
                    if (signatureInfo.keyPassword !== null && signatureInfo.keyPassword !== undefined) {
                        document.getElementById('keyPassword').textContent = signatureInfo.keyPassword;
                        document.getElementById('keyPasswordItem').style.display = 'block';
                    } else {
                        document.getElementById('keyPassword').textContent = 'æœªæ‰¾åˆ°ï¼ˆæ— æ³•ä»æ–‡ä»¶ä¸­æå–ï¼Œè¯·æŸ¥çœ‹å†å²è®°å½•ï¼‰';
                        document.getElementById('keyPasswordItem').style.display = 'block';
                    }

                    results.classList.add('show');

                } catch (err) {
                    if (err.message.includes('å¯†ç ') || err.message.includes('password') || err.message.includes('Mac verify')) {
                        throw new Error('å¯†ç é”™è¯¯æˆ–æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ã€‚è¯·ç¡®è®¤ï¼š\n1. å¯†ç æ˜¯å¦æ­£ç¡®\n2. æ–‡ä»¶æ˜¯å¦ä¸ºæœ‰æ•ˆçš„ PKCS#12 æ ¼å¼ï¼ˆ.keystore/.jksï¼‰');
                    }
                    throw err;
                }
            } catch (err) {
                console.error('Keystore è§£æé”™è¯¯:', err);
                throw new Error('Keystore è§£æé”™è¯¯: ' + err.message);
            }
        }

        async function extractFromSignatureBlock(arrayBuffer) {
            // å°è¯•ä» APK Signature Block v2/v3 ä¸­æå–è¯ä¹¦
            const view = new DataView(arrayBuffer);
            const length = arrayBuffer.byteLength;
            console.log('æœç´¢ç­¾åå—ï¼Œæ–‡ä»¶å¤§å°:', length);

            // æŸ¥æ‰¾ç­¾åå—ï¼ˆä»æ–‡ä»¶æœ«å°¾å¼€å§‹ï¼‰
            // APK Signature Block çš„ magic: "APK Sig Block 42" (16å­—èŠ‚)
            const magicBytes = [0x41, 0x50, 0x4B, 0x20, 0x53, 0x69, 0x67, 0x20,
                0x42, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x34, 0x32];

            // ä»æœ«å°¾å‘å‰æœç´¢ï¼ˆæœ€å¤šæœç´¢æœ€å 64KBï¼‰
            const searchRange = Math.min(65536, length);
            for (let i = length - searchRange; i < length - 16; i++) {
                let match = true;
                for (let j = 0; j < magicBytes.length; j++) {
                    if (view.getUint8(i + j) !== magicBytes[j]) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    console.log('æ‰¾åˆ°ç­¾åå—ï¼Œä½ç½®:', i);
                    // æ‰¾åˆ°äº†ç­¾åå—ï¼Œå°è¯•è§£æ
                    // ç­¾åå—ç»“æ„ï¼šsize (8 bytes) + block content + size (8 bytes) + magic (16 bytes)
                    try {
                        // è¯»å–ç­¾åå—å¤§å°ï¼ˆåœ¨ magic ä¹‹å‰ 8 å­—èŠ‚ï¼‰
                        const blockSizeOffset = i - 8;
                        if (blockSizeOffset >= 0) {
                            const blockSize = Number(view.getBigUint64(blockSizeOffset, true));
                            console.log('ç­¾åå—å¤§å°:', blockSize);

                            // è¯»å–ç­¾åå—å†…å®¹
                            const blockStart = blockSizeOffset - Number(blockSize);
                            if (blockStart >= 0 && blockStart < length) {
                                const blockData = new Uint8Array(arrayBuffer, blockStart, Number(blockSize));

                                // åœ¨ç­¾åå—ä¸­æŸ¥æ‰¾è¯ä¹¦
                                // è¯ä¹¦é€šå¸¸åœ¨ ASN.1 DER æ ¼å¼ä¸­ï¼ŒæŸ¥æ‰¾ 0x30 0x82 (SEQUENCE)
                                for (let k = 0; k < blockData.length - 100; k++) {
                                    if (blockData[k] === 0x30 && blockData[k + 1] === 0x82) {
                                        // å¯èƒ½æ˜¯è¯ä¹¦å¼€å§‹
                                        const certLength = (blockData[k + 2] << 8) | blockData[k + 3];
                                        if (certLength > 500 && certLength < 5000 && k + 4 + certLength <= blockData.length) {
                                            const certData = blockData.slice(k, k + 4 + certLength);
                                            console.log('åœ¨ç­¾åå—ä¸­æ‰¾åˆ°å¯èƒ½çš„è¯ä¹¦ï¼Œå¤§å°:', certData.length);
                                            return certData;
                                        }
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        console.warn('è§£æç­¾åå—å¤±è´¥:', err);
                    }
                    return null;
                }
            }

            console.log('æœªæ‰¾åˆ°ç­¾åå—');
            return null;
        }

        async function calculateHash(data, algorithm) {
            if (algorithm === 'MD5') {
                // ä½¿ç”¨ crypto-js è®¡ç®— MD5
                const wordArray = CryptoJS.lib.WordArray.create(data);
                const hash = CryptoJS.MD5(wordArray);
                // å°† WordArray è½¬æ¢ä¸º Uint8Array
                const words = hash.words;
                const sigBytes = hash.sigBytes;
                const result = new Uint8Array(sigBytes);
                for (let i = 0; i < sigBytes; i++) {
                    const byte = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    result[i] = byte;
                }
                return result;
            } else if (algorithm === 'SHA-1') {
                // ä½¿ç”¨ crypto-js è®¡ç®— SHA1
                const wordArray = CryptoJS.lib.WordArray.create(data);
                const hash = CryptoJS.SHA1(wordArray);
                const words = hash.words;
                const sigBytes = hash.sigBytes;
                const result = new Uint8Array(sigBytes);
                for (let i = 0; i < sigBytes; i++) {
                    const byte = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    result[i] = byte;
                }
                return result;
            } else {
                const hashBuffer = await crypto.subtle.digest(algorithm, data);
                return new Uint8Array(hashBuffer);
            }
        }


        function formatHash(hashArray, style = 'both') {
            // style å¯ä»¥æ˜¯ 'space', 'colon', æˆ– 'both'
            let separator = ' ';
            let colonSeparator = ':';

            let hashString = '';
            // å¦‚æœè¾“å…¥æ˜¯å­—ç¬¦ä¸²ï¼ˆæ¥è‡ª CryptoJSï¼‰ï¼Œç›´æ¥æ ¼å¼åŒ–
            if (typeof hashArray === 'string') {
                // ç§»é™¤å¯èƒ½å­˜åœ¨çš„ç©ºæ ¼æˆ–å†’å·
                hashString = hashArray.replace(/[\s:]/g, '').toUpperCase();
            } else {
                // å¦‚æœæ˜¯æ•°ç»„æˆ– Uint8Arrayï¼Œè½¬æ¢ä¸ºåå…­è¿›åˆ¶å­—ç¬¦ä¸²
                hashString = Array.from(hashArray)
                    .map(b => b.toString(16).padStart(2, '0').toUpperCase())
                    .join('');
            }

            const spaceFormat = hashString.match(/.{1,2}/g).join(' ');
            const colonFormat = hashString.match(/.{1,2}/g).join(':');

            if (style === 'space') {
                return spaceFormat;
            } else if (style === 'colon') {
                return colonFormat;
            } else {
                // è¿”å›ä¸¤ç§æ ¼å¼ï¼Œç”¨æ¢è¡Œåˆ†éš”
                return `ç©ºæ ¼æ ·å¼: ${spaceFormat}\nå†’å·æ ·å¼: ${colonFormat}`;
            }
        }

        // ä»å†å²è®°å½•ä¸­æŸ¥æ‰¾åŒ¹é…çš„ä¿¡æ¯
        function findMatchingHistory(publicKey, md5Hash) {
            try {
                const STORAGE_KEY = 'keystore_history';
                const stored = localStorage.getItem(STORAGE_KEY);
                if (!stored) return null;

                const history = JSON.parse(stored);

                // é€šè¿‡å…¬é’¥åŒ¹é…ï¼ˆæœ€å‡†ç¡®ï¼‰
                if (publicKey) {
                    const matchByPublicKey = history.find(item => {
                        const itemPublicKey = item.publicKey || '';
                        // æ¯”è¾ƒå…¬é’¥å­—ç¬¦ä¸²ï¼ˆå»é™¤ç©ºæ ¼ï¼‰
                        return itemPublicKey.toString().replace(/\s+/g, '') === publicKey.toString().replace(/\s+/g, '');
                    });
                    if (matchByPublicKey) {
                        console.log('é€šè¿‡å…¬é’¥åŒ¹é…åˆ°å†å²è®°å½•:', matchByPublicKey.packageName);
                        return matchByPublicKey;
                    }
                }

                // é€šè¿‡ MD5 åŒ¹é…ï¼ˆå¤‡ç”¨æ–¹æ³•ï¼‰
                if (md5Hash) {
                    const matchByMd5 = history.find(item => {
                        const itemMd5 = (item.md5 || '').replace(/\s+/g, '').toUpperCase();
                        const searchMd5 = md5Hash.replace(/\s+/g, '').toUpperCase();
                        return itemMd5 === searchMd5;
                    });
                    if (matchByMd5) {
                        console.log('é€šè¿‡ MD5 åŒ¹é…åˆ°å†å²è®°å½•:', matchByMd5.packageName);
                        return matchByMd5;
                    }
                }

                return null;
            } catch (err) {
                console.warn('æŸ¥æ‰¾å†å²è®°å½•å¤±è´¥:', err);
                return null;
            }
        }

        async function extractPublicKey(certData) {
            // è§£æ X.509 è¯ä¹¦å¹¶æå– RSA å…¬é’¥çš„ modulus
            // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„å®ç°ï¼Œå®é™…éœ€è¦å®Œæ•´çš„ ASN.1 è§£æå™¨

            try {
                // æŸ¥æ‰¾ RSA å…¬é’¥çš„ modulus (n)
                // åœ¨ DER ç¼–ç çš„è¯ä¹¦ä¸­ï¼Œmodulus é€šå¸¸å‡ºç°åœ¨ç‰¹å®šä½ç½®
                // è¿™é‡Œä½¿ç”¨ç®€åŒ–çš„æœç´¢æ–¹æ³•

                const data = new Uint8Array(certData);
                // æŸ¥æ‰¾ SEQUENCE æ ‡ç­¾å’Œå¯èƒ½çš„ modulus
                // å®é™…åº”è¯¥ä½¿ç”¨å®Œæ•´çš„ ASN.1 è§£æåº“

                // ä½œä¸ºæ¼”ç¤ºï¼Œè¿™é‡Œè¿”å›ä¸€ä¸ªå ä½ç¬¦
                // å®é™…åº”ç”¨ä¸­åº”è¯¥ä½¿ç”¨å®Œæ•´çš„è¯ä¹¦è§£æåº“
                return await parseRSAPublicKey(certData);
            } catch (err) {
                console.warn('æå–å…¬é’¥å¤±è´¥:', err);
                return null;
            }
        }

        async function parseRSAPublicKey(certData) {
            // ç›´æ¥ä½¿ç”¨å¤‡ç”¨æ–¹æ³•ï¼Œå› ä¸ºå®ƒæ›´å¯é 
            return await parseRSAPublicKeyFallback(certData);
        }

        async function parseRSAPublicKeyFallback(certData) {
            // å¤‡ç”¨æ–¹æ³•ï¼šå°è¯•åœ¨è¯ä¹¦æ•°æ®ä¸­æŸ¥æ‰¾ RSA modulus
            // è¿™æ˜¯ä¸€ä¸ªå¯å‘å¼æ–¹æ³•ï¼Œå¯èƒ½ä¸æ€»æ˜¯å‡†ç¡®
            const data = new Uint8Array(certData);
            console.log('å¼€å§‹è§£æ RSA å…¬é’¥ï¼Œæ•°æ®é•¿åº¦:', data.length);

            // RSA modulus é€šå¸¸æ˜¯ä¸€ä¸ªå¤§æ•´æ•°ï¼Œåœ¨è¯ä¹¦ä¸­æœ‰ç‰¹å®šçš„ ASN.1 ç»“æ„
            // INTEGER æ ‡ç­¾æ˜¯ 0x02ï¼Œåé¢è·Ÿé•¿åº¦ï¼ˆå¯èƒ½æ˜¯ 1 å­—èŠ‚æˆ–æ›´å¤šï¼‰

            let bestModulus = null;
            let bestModulusSize = 0;
            let candidateCount = 0;

            // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„ INTEGER æ ‡ç­¾
            for (let i = 0; i < data.length - 10; i++) {
                if (data[i] === 0x02) { // INTEGER tag
                    let length;
                    let offset = i + 1;

                    if (offset >= data.length) continue;

                    // è§£æé•¿åº¦ï¼ˆå¯èƒ½æ˜¯çŸ­æ ¼å¼æˆ–é•¿æ ¼å¼ï¼‰
                    if ((data[offset] & 0x80) === 0) {
                        // çŸ­æ ¼å¼ï¼šé•¿åº¦åœ¨ 1 å­—èŠ‚ä¸­
                        length = data[offset];
                        offset += 1;
                    } else {
                        // é•¿æ ¼å¼ï¼šç¬¬ä¸€ä¸ªå­—èŠ‚çš„ä½ 7 ä½è¡¨ç¤ºåç»­é•¿åº¦å­—èŠ‚æ•°
                        const lengthBytes = data[offset] & 0x7F;
                        if (lengthBytes === 0 || lengthBytes > 4 || offset + lengthBytes >= data.length) continue;
                        offset += 1;
                        length = 0;
                        for (let j = 0; j < lengthBytes; j++) {
                            length = (length << 8) | data[offset + j];
                        }
                        offset += lengthBytes;
                    }

                    // æ£€æŸ¥é•¿åº¦æ˜¯å¦åˆç†ï¼ˆRSA modulus é€šå¸¸æ˜¯ 128-512 å­—èŠ‚ï¼Œä½†ä¹Ÿå¯ä»¥æ˜¯ 256, 512, 1024 ä½ç­‰ï¼‰
                    if (length >= 128 && length <= 512 && offset + length <= data.length) {
                        candidateCount++;
                        const modulusBytes = data.slice(offset, offset + length);

                        // æ£€æŸ¥ç¬¬ä¸€ä¸ªå­—èŠ‚ï¼ŒRSA modulus ä¸åº”è¯¥ä»¥ 0 å¼€å¤´ï¼ˆé™¤éæ˜¯è´Ÿæ•°ï¼Œä½†å…¬é’¥ä¸ä¼šæ˜¯è´Ÿæ•°ï¼‰
                        if (modulusBytes[0] === 0 && length > 128) {
                            // è·³è¿‡å‰å¯¼é›¶
                            let startIdx = 0;
                            while (startIdx < modulusBytes.length - 1 && modulusBytes[startIdx] === 0) {
                                startIdx++;
                            }
                            if (startIdx > 0) {
                                // ä½¿ç”¨å»æ‰å‰å¯¼é›¶åçš„æ•°æ®
                                const actualModulusBytes = modulusBytes.slice(startIdx);
                                if (actualModulusBytes.length < 128) continue;

                                // è½¬æ¢ä¸ºå¤§æ•´æ•°
                                let modulusInt = BigInt(0);
                                for (let j = 0; j < actualModulusBytes.length; j++) {
                                    modulusInt = modulusInt * BigInt(256) + BigInt(actualModulusBytes[j]);
                                }

                                const modulusStr = modulusInt.toString();
                                if (modulusStr.length > 200 && modulusInt > BigInt('1' + '0'.repeat(200))) {
                                    if (actualModulusBytes.length > bestModulusSize) {
                                        bestModulus = modulusInt.toString();
                                        bestModulusSize = actualModulusBytes.length;
                                    }
                                }
                                continue;
                            }
                        }

                        // è½¬æ¢ä¸ºå¤§æ•´æ•°
                        let modulusInt = BigInt(0);
                        for (let j = 0; j < modulusBytes.length; j++) {
                            modulusInt = modulusInt * BigInt(256) + BigInt(modulusBytes[j]);
                        }

                        // éªŒè¯æ˜¯å¦çœ‹èµ·æ¥åƒ RSA modulusï¼ˆå¾ˆå¤§ï¼Œé€šå¸¸æ˜¯å¥‡æ•°ï¼‰
                        const modulusStr = modulusInt.toString();
                        if (modulusStr.length > 200 && modulusInt > BigInt('1' + '0'.repeat(200))) {
                            // é€‰æ‹©æœ€å¤§çš„ç¬¦åˆæ¡ä»¶çš„ modulusï¼ˆé€šå¸¸æ˜¯çœŸæ­£çš„ modulusï¼‰
                            if (length > bestModulusSize) {
                                bestModulus = modulusInt.toString();
                                bestModulusSize = length;
                            }
                        }
                    }
                }
            }

            console.log('æ‰¾åˆ°', candidateCount, 'ä¸ªå€™é€‰ modulusï¼Œæœ€ä½³é•¿åº¦:', bestModulusSize);

            if (bestModulus) {
                return bestModulus;
            }

            return 'æ— æ³•æå–å…¬é’¥ï¼Œè¯·ç¡®ä¿ APK å·²æ­£ç¡®ç­¾å';
        }

        function showError(message) {
            error.textContent = message;
            error.classList.add('show');
        }

        // æ·»åŠ å¤åˆ¶åŠŸèƒ½
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('copy-btn')) {
                const targetId = e.target.getAttribute('data-target');
                const style = e.target.getAttribute('data-style');
                const targetElement = document.getElementById(targetId);

                if (targetElement) {
                    let value = '';

                    // å¦‚æœæœ‰æŒ‡å®šæ ·å¼ï¼Œä»åŸå§‹æ•°æ®æ ¼å¼åŒ–
                    if (style && window.lastHashData) {
                        const hashKey = targetId; // md5, sha1, sha256
                        if (window.lastHashData[hashKey]) {
                            value = formatHash(window.lastHashData[hashKey], style);
                        }
                    } else {
                        // æ²¡æœ‰æŒ‡å®šæ ·å¼ï¼Œå¤åˆ¶æ•´ä¸ªå†…å®¹
                        value = targetElement.textContent.trim();
                    }

                    if (value && value !== '-') {
                        navigator.clipboard.writeText(value).then(() => {
                            const originalText = e.target.textContent;
                            e.target.textContent = 'å·²å¤åˆ¶!';
                            e.target.style.background = '#28a745';
                            setTimeout(() => {
                                e.target.textContent = originalText;
                                e.target.style.background = '';
                            }, 2000);
                        }).catch(err => {
                            console.error('å¤åˆ¶å¤±è´¥:', err);
                            e.target.textContent = 'å¤åˆ¶å¤±è´¥';
                            setTimeout(() => {
                                e.target.textContent = originalText;
                            }, 2000);
                        });
                    }
                }
            }
        });
    </script>
    <script src="../../assets/js/tools.js"></script>
    <script src="../../assets/js/themes.js"></script>
    <script src="../../assets/js/theme-ui.js"></script>
</body>

</html>